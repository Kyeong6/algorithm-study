## 개념 정리

### 힙(Heap)이란?

- 최소값이나 최대값에 접근하는 데 최적화된 자료구조
- 힙은 완전 이진 트리(Complete Binary Tree)를 기반으로 하는 자료구조로, 힙에 데이터를 저장해놓으면 O(1), 즉 상수 시간에 최소값이나 최대값에 접근할 수 있음
    - 힙이 최소값 또는 최대값을 트리의 루트(root)에 저장해놓기 때문
- 최소값을 트리의 루트에 위치시키는 힙을 최소힙(Min Heap)이라고 하고, 최대값을 트리의 루트에 위치시키는 힙을 최대힙(Max Heap)이라고 함
- Min Heap

```python
     1
   /   \
  3     2
 / \   /
4   6 5
```

- Max Heap

```python
     6
   /   \
  5     3
 / \   /
4   2 1
```

- 힙에서 값을 연속해서 꺼내면 자동으로 정렬되는 효과가 나기 때문에 기본적으로 정렬에 활용할 수 있음
    - 몇 번째로 가장 작은 값 또는 가장 큰 값을 구해야하는 상황에서 유요하게 사용할 수 있음
    - 3번째로 작은 값이 필요하다면 최소힙에서 3번 값을 꺼내면 됨
    - **왜냐하면 root 노드의 값을 빼면 자동으로 정렬되기 때문!**

### 힙의 맹점

- 힙은 내부 구조를 항상 최소값 또는 최대값을 제공하기 위한 최적의 상태로 유지해야 함
    - 즉, 최소값이나 최대값을 항상 트리의 루트에 위치시켜야 함
    - **힙에 값을 추가할 때 내부적으로 트리 상에서 값들 재배치 필요!**
- 힙을 구현할 때 완전 이진 트리를 사용하는 이유는 값을 추가할 때 들어가는 비용을 O(log n)으로 제한할 수 있기 때문
    - **가장 빠르게 정렬할 수 있는 방식이 이진 탐색!**
- 최소힙을 기준으로 생각해보면, 최악의 경우 현재 힙에 저장되어 있는 모든 값보다 더 작은 값이 추가될 수 있을텐데, 이럴 경우 그 값은 트리의 말단(leaf)부터 시작해서 트리의 최상단(root)까지 자기보다 작은 값들과 자리를 계속해서 바꾸면서 올라가야 함
- 그래서 비어있는 힙에 데이터를 저장해야하는 상황이라면 완전히 이야기가 달라질 수 있는데, 저장해야하는 값의 개수가 n이라고 하면, 모든 값을 저장하는데 O(nlogn)의 시간이 소요
- 따라서 힙에 데이터를 저장하는 데 소요되는 시간을 고려하지 않으면 오히려 안 쓰니만 못한 자료구조가 될 수 있음
    - 예를 들어, 배열에서 최소값을 구하기 위해서 힙을 사용하는 것은 배보다 배꼽이 더 큰 상황
    - 그냥 간단하게 선형 탐색을 하면 O(n) 시가에 해결 될일을 괜히 힙을 써서 O(nlogn)의 시간이 처리하는 꼴이기 때문

### 코딩 테스트에서 활용

- 위에서 설명한 것처럼 전체 데이터를 저장해야하는 문제에서는 득보다 해가 되는 경우가 많지만, 일부 데이터만을 저장할 수 있는 상황에서는 힙이 큰 빛을 발휘
- k번째로 작은 값이나 큰 값을 구하는 유형의 문제가 도움이 되는데, 크기가 k인 힙 하나만 있으면 문제는 아주 수월하게 해결할 수 있음
    - k번째로 작은 값이 필요하다면 최대힙을 사용되고, k번째로 큰 값이 필요하다면 최소힙을 사용하면 됨
- 헷갈릴만한 요소인데, 만약 k번째로 큰 값을 구하려고 한다면
    - 주어진 데이터 세트(배열, 집합, 링크드 리스트 등등)를 처음부터 끝까지 차례로 스캔
    - 처음 k개의 값은 무조건 최소힙에 넣어서 우선 꽉 채움
        - 기존에 최소힙에 저장되어 있던 값이 더 작다면 그 값을 최소힙에서 제거하고 새로운 값을 최소힙에 추가
        - 새로운 값이 더 작다면 다음 값으로 넘어감
    - 이 작업을 마지막 값까지 반복해주면 최종적으로 최소힙에는 여태까지 나온 가장 큰 k개의 값만 남을 것

## 프로그래밍

### 힙 자료구조

- heapq 모듈은 이진 트리 기반의 최소 힙 자료구조 제공
- min heap을 사용하면 원소들이 항상 정렬된 상태로 추가되고 삭제되며, min heap에서 가장 작은 값은 언제나 인덱스0, 즉 이진 트리 루트에 위치
- 내부적으로 min heap내의 모든 원소(k)는 항상 자식 원소들(2k+1, 2k+2)보다 크기가 작거나 같도록 원소가 추가되고 삭제

```python
heap[k] <= heap[2*k+1] and heap[k] <= heap[2*k+2]
```

```python
     1  ---> root
   /   \
  3     5
 / \   /
4   8 7
```

### 최소 힙 생성

- heapq 모듈에는 Python의 보통 리스트를 마치 최소 힙처럼 다룰 수 있도록 도와줌
- 그냥 빈 리스트를 생성해놓은 다음 heapq 모듈의 함수를 호출할 때마다 이 리스트를 인자로 넘겨야 함
    - heapq 모듈을 통해서 원소를 추가하거나 삭제한 리스트가 그냥 최소 힙

### 힙에 원소 추가

- heapq 모듈의 heappush() 함수를 이용하여 힙에 원소 추가 가능
- 첫번째 인자는 원소를 추가할 대상 리스트이며, 두번째 인자는 추가할 원소를 넘김

```python
from heapq import headppush

heappush(heap, 4)
heappush(heap, 7)
heappush(heap, 1)
heappush(heap, 3)
print(heap) # [1,3,7,4]
```

- 가장 작은 1이 root이며, 인덱스 1에 위치한 3은 인덱스 3에 위치한 4보다 크므로 힙의 공식 만족
    - 내부적으로 이진 트리에 원소를 추가하는 heappush() 함수는 O(logn)의 시간 복잡도 가짐

### 힙에서 원소 삭제

- heapq 모듈의 heappop() 함수를 이용하여 힙에서 원소를 삭제할 수 있음
    - 원소를 삭제할 대상 리스트를 인자로 넘기면, 가장 작은 원소를 삭제 후에 그 값을 리턴

```python
from heapq import heappop

print(heappop(heap))
print(heap) 
"""
1
[3,4,7]
"""
```

- 최소값(인덱스 0)이 삭제되어 리턴되었고, 그 다음으로 작은 3이 인덱스 0으로 올라옴
    - 내부적으로 이진 트리로부터 원소를 삭제하는 heappop() 함수도 역시 O(logn)의 시간복잡도를 가짐

### 최소값 삭제하지 않고 얻기

- 힙에서 최소값을 삭제하지 않고 단순히 읽기만 하려면 일반적으로 리스트의 첫번째 원소에 접근하듯이 인덱스를 통해 접근하면 됨

```python
print(heap[0])
```

- 주의 사항은 인덱스 0에 가장 작은 원소가 있다고 해서, 인덱스 1에 두번째 작은 원소, 인덱스 2에 세번째 작은 원소가 있다는 보장은 없음
    - 힙은 heappop() 함수를 호출하여 원소를 삭제할 때마다 이진 트리의 재배치를 통해 매번 새로운 최소값을 인덱스 0에 위치시키기 때문
- 따라서 두 번째로 작은 원소를 얻으려면 바로 heap[1]으로 접근하면 안 되고, 반드시 heappop()을 통해 가장 작은 원소를 삭제 후에 heap[0]를 통해 새로운 최소값에 접근해야 함
    - **결국 heappop()을 통해서 값을 확인하는 게 제일 좋은 방법!**

### 기존 리스트를 힙으로 변환

- 이미 원소가 들어있는 리스트 힙으로 만들려면 heapq 모듈의 heapify() 라는 함수 사용

```python
from heapq import heapify

heap = [4,1,7,3,8,5]
heapify(heap)
print(heap) # [1,3,5,4,8,7]
```

- heapify() 함수에 리스트를 인자로 넘기면 리스트 내부의 원소들의 위에서 다룬 힙 구조에 맞게 재배치되며 최소값이 0번째 인덳에 위치
- 즉, 비어있는 리스트를 생성한 후 heappush() 함수로 원소를 하나씩 추가한 효과
- heapify() 함수의 성능은 인자로 넘기는 리스트에 비례하므로, O(n)의 시간복잡도 가짐
- heapify() 함수를 사용할 때 주의할 점은 새로운 리스트를 반환하는 것이 아니라 인자로 넘긴 리스트에 직접 변경하기 때문에 원본 리스트의 형태를 보존해야되는 경우에 반드시 해당 리스트를 복제한 후에 인자로 넘기기

### [응용] 최대 힙

- heapq 모듈은 최소 힙 기능만 동작하기 때문에 힙에 튜플(tuple)를 원소로 추가하거나 삭제하면, 튜플 내에서 맨 앞에 있는 값을 기준으로 최소 힙이 구성되는 원리를 이용하는 것
- 따라서 최대 힙을 만들려면 각 값에 대한 우선 순위를 구한 후, (우선 순위, 값) 구조의 튜플(tuple)을 힙에 추가하거나 삭제하면 됨
    - 그리고 힙에서 값을 읽어올 때는 각 튜플에서 인덱스 1에 있는 값을 취하면 됨(우선 순위에는 관심없으므로)

```python
from heapq import heappush, heappop

nums = [4,1,7,3,8,5]
heap = []

for num in nums:
	heappush(heap, (-num, num)) # (우선 순위, 값)

while heap:
	print(heappop(heap)[1]) # index 1

"""
8
7
5
4
3
1
"""
```

### [응용] n번째 최소값/최대값

- 최소 힙이나 최대 힙을 사용하면 n번째로 작은 값이나 n번째로 큰 값을 효과적으로 구할 수 있음
- n번째 최소값을 구하기 위해서는 주어진 배열로 힙을 만든 후 heappop() 함수를 n번 호출하면 됨

```python
from heapq import heappush, heappop

def nth_smallest(nums, n):
	heap = []
	for num in nums:
		heappush(heap, num)
	nth_min = None
	for _ in range(n):
		nth_min = heappop(heap)
		
	return nth_min
	
print(nth(smallest([4,1,7,3,8,5], 3)) # 3
```

- heapify() 함수를 활용하면 힙을 만들 때 굳이 루프를 돌면서 매 번 하나씩 추가해줄 필요가 없음!

```python
from heapq import heapify, heappop

def nth_smallest(nums, n):
	heapify(nums)
	
	nth_min = None
	for _ in range(n):
		nth_min = heappop(nums)
		
	return nth_min
```

- 사실 heapq 모듈에 이미 이러한 용도로 사용할 수 있는 nsmallest() 라는 함수가 존재함
    - nsmallest() 함수는 주어진 리스트에서 가장 작은 n개의 값을 담은 리스트를 반환하는데, 그 결과 리스트의 마지막이 n번째 작은 값이 됨

```python
from heapq import nsmallest

nsmallest(3, [4,1,7,3,8,5])[-1]
```

- 반대로 n번째  최대값을 구할 때는 nlargest() 함수를 사용하면 됨

```python
from heapq import nlargest

nlargest(3, [4,1,7,3,8,5])[-1]
```

### [응용] 힙정렬

```python
from heapq import heappush, heappop

def heap_sort(nums):
	heap = []
	for num in nums:
		heappush(heap, num)
		
	sorted_nums = []
	while heap:
		sorted_nums.append(heapppop(heap))
	return sorted_nums
	
print(heap_sort([4,1,7,3,8,5])) # [1,3,4,5,7,8]
```