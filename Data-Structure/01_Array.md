## 개념 정리

### 순서있게 값을 저장

- 배열의 가장 중요한 특징은 값을 index를 사용하여 순서있게 저장한다는 것
    - 인덱스를 통해서 특정 위치에 저장되어 있는 값을 상수 시간 O(1)에 읽고 쓸 수 있음
- 배열 arr가 있을 때 인덱스 3의 값을 ‘D’에서 ‘K’로 변경하면 다음과 같다

```python
print(arr[3]) # D
arr[3] = 'K'
print(arr[3]) # K
```

### 같은 값을 중복해서 저장

- 배열에는 동일한 값을 여러 번 저장 가능(집합과는 다른 특징)
- 왜냐하면 값이 동일하더라도 인덱스가 틀리기 때문에 데이터의 중복이 전혀 문제가 되지 않음

### 배열 순회

- 배열에 저장된 모든 값에 접근하기 위해서는 루프를 돌아야한다
- python에서는 for문을 사용하여 인덱스 i를 통해서 값에 접근하는 코딩 패턴이 많이 사용

```python
for i in range(n):
	print(i)
```

### 배열의 크기

- 일반적으로 배열은 메모리에서 특정 부분을 선점하기 때문에 배열에 저장할 수 있는 값의 개수는 고정됨
    - 배열(리스트) 자료형은 메모리 적재를 수행하기 때문에 CPU 바운드 작업
    - Python 코딩과정에서 리스트를 사용하지 않고 Generator Expression을 사용하면 메모리 적재 수행하지 않음
- 결국 **배열은 저장해야 할 값의 개수를 미리 알 수 없을 때는 매우 비효율적인 자료구조**가 될 수 있음
    - 배열의 크기를 초과하는 개수의 값을 저장하기 위해서는 새로운 배열을 만들어서 기존 배열에 있던 모든 값을 복사해줘야하기 때문(Copy 수행 필요하기 때문)

### 중간에 있는 값 삽입 / 삭제

- **값을 맨 뒤가 아니라 중간에 삽입하거나 삭제해야 한다면 배열은 자료구조로서 최악의 선택**이 될 수 있음
    - 기존에 저장되어 있는 많은 값들을 모두 한 칸씩 밀어줘야하는 shift 작업이 수반되는데 이게 매우 비효율적이기 때문
- 이렇게 값을 중간에서 삭제하거나 삽입해야 할 일이 많다면 **Linked List**가 좋은 대안

## 프로그래밍

### 기본 정의

- 리스트는 가변(mutable)자료형이기 때문에 리스트를 생성 후에 자유롭게 새로운 데이터를 추가하거나 기존 데이터 변경 혹은 제거 가능
    - 이와 반대로 튜플은 불변(immutable)한 자료형

### 데이터 추가

- append : 뒤에 추가

```python
fruits = list()
fruits.append('Apple')
fruits.append('Banana')
fruits # ['Apple', 'Banana']
```

- insert : 특정 인덱스에 추가 → 결국 중간에 들어가면 뒤에가 밀리기 때문에 성능이 좋지 않음
    - 결국 insert 사용은 지양하는 게 좋을 듯
    - 원소를 리스트의 앞에서 넣을 일이 많다면 deque, Queue와 같은 자료형 고려

### 리스트 슬라이싱

- 리스트 거꾸로 출력

```python
fruits[::-1] # ['Banana', 'Apple']
```

### 데이터 갱신

- 리스트는 가변 자료형이기 때문에 저장하고 있는 데이터를 자유롭게 갱신 가능, 기존 인덱스에 새로운 값 할당하기만 하면 기존 값이 새로운 값으로 대체

```python
fruits[1] = 'Kiwi'
fruits # ['Banana', 'Kiwi']
```

- 여러 데이터 갱신

```python
fruits[:2] = ['Apple', 'Banana']
fruits # ['Apple', 'Banana']
```

### 데이터 삭제

- 특정 키워드 삭제

```python
fruits.remove('Banana')
fruits # ['Apple']
```

- 인덱스 기반 삭제

```python
fruits.pop()
fruits # []
```

pop 함수는 인자로 인덱스를 설정할 수 있는데 여기서 기본인자를 제외하고 다른 값인 인덱스를 넣으면 어떻게될까? 데이터 삽입에서의 insert와 마찬가지로 중간에 들어가는 상황이기 때문에 성능상 좋지 않다. 

### 리스트 순회

- 인덱스와 원소를 동시에 얻기

```python
fruits = ['Apple', 'Banana', 'Kiwi']

for idx, fruit in enumerate(fruits):
	print(idx+1, fruit)

"""
1 Apple
2 Banana
3 Kiwi
"""
```

### 데이터 존재 여부 확인

- in 연산자 사용 → 조건문과 많이 사용

```python
if "Apple" in fruits:
	print("Yes")
else:
	print("No")
# Yes
```

### 리스트 병합

- + 연산자 사용

```python
li1 = ["A", "B"]
li2 = ["C", "D"]
li3 = li1 + li2
li3 # ["A", "B", "C", "D"]
```

## 정리

- 배열은 값을 순서 있게 저장하는 자료구조로, 인덱스를 통해 매우 빠르게(O(1)) 값에 **접근**하거나 **갱신**할 수 있음
- 배열은 저장해야할 값의 개수를 미리 알 수 없을 때는 매우 비효율적인 자료구조
    - 기존 배열 Copy를 통한 새로운 배열을 생성하기 때문
- 값을 맨 끝이 아닌 중간에서 삭제하거나 삽입해야할 때는 적합하지 않음
    - 한 칸씩 밀어줘야하는 Shift 작업이 수반되기 때문
    - 이때는 Linked List를 사용