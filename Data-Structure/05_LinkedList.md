## 개념 정리

### 링크드 리스트(Linked list)란?

- 배열과 유사한 자료구조로서 코딩 테스트 자주 등장하는 자료구조

![스크린샷 2025-01-04 오후 10 06 19](https://github.com/user-attachments/assets/ff477408-b8b2-4ffa-aea8-318599d001b0)

- 노드(node)라고 일컽는 객체의 일부로 데이터를 저장하며 링크드 리스트 상에서 각 노드에는 다음 노드를 가리키고 있는 레퍼런스(reference) 또는 포인터(pointer)도 함께 저장되어 있음
- 즉, 하나의 노드에는 두 가지 정보를 담고있음
    - 데이터 값(value)
    - 다음 노드의 레퍼런스(next)
- 링크드 리스트는 어떤 일련의 데이터를 처음부터 끝까지 쭉 탐색하기 매우 적합한 구조

### 배열과 비교

- 링크드 리스트와 배열은 여러 개의 데이터를 차례대로 저장할 수 있다는 상당히 유사하지만 차이점이 존재
- 배열 :
    - 일반적으로 많은 언어에서 크기가 고정, 데이터를 추가하거나 삭제하는 데 불리한 자료구조
        - insert / pop 메서드 생각
    - 왜냐하면 배열은 메모리 상의 연속된 영역을 차지해야하기 때문에 유연하게 크기를 줄이거나 늘리기 어려운 구조
    - 대신 배열은 인덱스를 데이터를 매우 빠르게 접근이 가능
        - O(1)
- 링크드 리스트 :
    - 크기에 제한이 없는 경우가 많으며, 데이터를 추가하거나 삭제하기 유리한 자료구조
    - 링크드 리스트에 저장되어 있는 노드들은 메모리 상에서 좀 더 자유롭게 위치할 수 있음
        - 이전 노드에 다음 노드가 메모리 상에 어디에 위치하는 지 저장이 되어있기 때문(위치 정보를 알고 있어서 이때, 가상 메모리 개념도 존재!)
- 데이터 무작위 접근(random access)에 최적화되어 있는 배열과 달리 링크드 리스트는 특정 데이터에 접근하는데 시간이 오래걸림
    - 맨 첫 번째 노드부터 원하는 값을 찾을 때 까지 자료구조를 전체를 순회를 해야하기 때문에 시간 복잡도가 ‘O(n)’
        - 노드 개수에 영향을 받기 때문에 n개라고 가정할 경우 최악의 경우 n번 탐색 필요
- 정리하면 성능 측면에서 링크드 리스트는 데이터의 추가와 삭제에 강점이 있는 반면, 배열은 데이터 접근에 강점이 있음
    - 데이터를 단순히 읽는 작업이 많은 프로그램은 배열 유리
    - 데이터의 추가/삭제가 잦은 프로그램은 링크드 리스트 유리

### 코딩 테스트 활용

- 링크드 리스트는 비교적 간단한 자료구조이지만 여러가지 방법으로 응용해서 문제 내기가 좋음

```python
class Node:
	def __init__(self, value, next = None):
		self.value = value
		self.next = next
```

- 링크드 리스트는 하나의 객체이기 때문에 class를 이용하여 구현하고, 데이터 값을 저장하기 위해서 ‘value’ 인스턴스 변수가 필요하고, 다음 노드의 레퍼런스를 저장하기 위해서 ‘next’ 인스턴스 변수가 필요
- 코딩 테스트 한해서는 링크드 리스트 자료구조 자체를 나타내는 클래스는 정의할 일이 거의 없음, 온라인 코딩 시험이라면 위와 같은 클래스에 대한 코드가 미리 작성되어 제공되는 경우도 많음
- 링크드 리스트와 관련된 코딩 문제에서는 대부분의 경우 링크드 리스트의 첫 번째 노드가 입력으로 주어지는데, 이 첫 번째 노드를 이용해서 링크드 리스트 상의 모드 노드를 하나씩 순회해야하는 경우가 많음
- 이럴 때는 다음 코딩 패턴이 매우 유용

```python
# 첫 번째 노드를 'node' 변수에 저장
node = head 
# 'node' 변수에 저장된 노드가 있는 동안 반복
while node:
	do_something(node) # 현재 노드를 대상으로 어떤 작업 수행
	node = node.next # 다음 노드를 'node' 변수에 저장
```

- 여기서 ‘node’ 변수에 저장된 노드가 있는 동안만 반복하는 이유는 ‘node’에 저장된 노드가 없다면 링크드 리스트의 제일 마지막에 도달하여 더 이상 처리할 노드가 없다는 뜻이기 때문
- 링크드 리스트와 관련된 코딩 문제를 풀때는 보통 이러한 반복문이 필요하기 때문에 모범 답안의 시간 복잡도가 ‘O(n)’ 인 경우가 많음

### 시간 복잡도

- 링크드 리스트의 맨 앞 데이터를 추가 / 삭제하는 것은 단순히 포인터를 바꿔주는 작업 : O(1)
- 데이터에 접근할 때는 링크드 리스트의 각 노드를 하나씩 순회 : O(n)