## 개념 정리

### 재귀 알고리즘이란?

- 함수 내부에서 자기 자신을 다시 호출하는 특수한 형태의 함수인 재귀 함수를 이용하는 알고리즘
- 재귀 알고리즘을 사용하면, 크고 복잡한 문제가 주어졌을 때, 문제의 크기를 결과를 얻을 수 있을 정도까지 점진적으로 줄인 다음에, 바로 그 결과를 이용하여 거꾸로 점점 더 큰 문제를 풀다가, 결국에는 맨처음에 주어진 크기의 문제를 해결할 수 있음

```python
def factorial(n):
	if n == 0: # 기저 조건
		return False
	return n * factorial(n-1) # 재귀 호출
```

- 재귀 함수는 대부분 위와 같이 비슷한 형태를 띰
    - 맨 위에서 기저 조건을 설정하고, 그 아래에는 자기 자신을 호출
    - 기저 조건에 도달하기 위해서 매번 호출할 때 마다 더 작거나 큰 인수를 넘기며, 자기 자신을 몇 번 호출해야 할지는 해결해야 할 문제에 따라 다름
- 시각화하면 다음과 같음

```python
factorial(5)
    factorial(4)
        factorial(3)
            factorial(2)
                factorial(1)
                    factorial(0)
                    ↳ 1
                ↳ 1 * 1 = 1
            ↳ 2 * 1 = 2
        ↳ 3 * 2 = 6
    ↳ 4 * 6 = 24
↳ 5 * 24 = 120
```

- 호출 스택이 깊어짐에 따라 인수가 점점 작아지고 결국 기저 조건에 도달하면 다시 **스택**을 타고 거꾸로 거슬러올라오면서 결과가 계산
    - **재귀 알고리즘 정의에서 언급한대로 일단 함수호출을 해서 기저 조건까지 진행한 다음에 결과를 반환하구나! → 스택!**
- Top-down 방향으로 문제 접근하게 되며, 더 큰 문제의 결과를 구하려면 더 작은 문제의 결과가 구해질 때 까지 기다리는 과정 수반
    - **이게 재귀 알고리즘이 성능이 그닥 좋지 않다는 이유인 듯!**

### 코딩 테스트에서 활용

- 코딩 테스트를 보면 적어도 두 문제 중 한 문제는 재귀 알고리즘으로 풀 수 있을 정도로, 재귀 알고리즘을 통해 해결할 수 있는 문제가 코딩 테스트에서 많이 출제
- 링크드 리스트, 이진 트리, 그래프와 같은 자료구조와 관련된 문제에서 많이 사용
    - 위와 같은 자료 구조는 Top-down 방향으로 탐색해야하는 경우가 많기 때문
- 순열이나 조합과 같이 경우의 수를 따지는 문제에서도 많이 활용
    - 주어진 큰 문제를 해결하기 위해서는 재귀 함수를 통해 작은 문제로 쪼개서 해결한 후에 그 결과를 합쳐야 하기 때문

### 주의 사항

- 반복 알고리즘을 사용하는 코드를 작성할 때 조심해야하는 부분 존재
- 자기 자신을 호출하는 재귀 함수의 특성 상 무한 루프에 빠지기 쉬움
    - 재귀 함수가 반드시 종료될 수 있도록 항상 **기저 조건(base case)**을 신중하게 설정 필요!
- 스택 오버 플로우 문제
    - 모든 코드는 결국 물리적인 하드웨어에서 돌아가기 때문에 호출 스택의 크기가 제한되어 있음
    - 재귀 알고리즘이 수행되는 도중, 호출 스택이 너무 깊어져서 이 제한된 크기를 초과하게 되면 프로그램 강제 종료될 수 있음
- 위와 같은 문제 때문에 상용 소프트웨어를 개발할 때는 기피하는 경향 존재
    - 무한 루프에 빠지든 스택 오버 플로우가 발생하든 해당 소프트웨어는 작동할 수 없는 상태가 되기 때문

### 반복 알고리즘과 비교

- 재귀 알고리즘의 라이벌로는 반복(Iteration) 알고리즘 존재
    - 동일한 문제를 반복 알고리즘으로도 풀 수 있고, 재귀 알고리즘으로도 풀 수 있는 경우가 많아서 자주 비교됨
- 재귀 알고리즘

```python
def factorial(n):
	if n == 0: # 기저 조건
		return False
	return n * factorial(n-1) # 재귀 호출
```

- 반복 알고리즘

```python
def factorial(n):
	result = 1
	for i in range(n):
		result = result * (i+1)
	return result
```

- 재귀 알고리즘 코드를 반복 알고리즘으로, 반복 알고리즘을 재귀 알고리즘으로 바꾸는 연습하기!
    - 코딩 면접에서 물어봄

### 복잡도 분석

- 재귀 알고리즘의 복잡도 분석을 어려워하는 경우 많음
- 반복 알고리즘 같은 경우 코드를 통해 분석하면 되지만, 재귀 알고리즘은 재귀 함수가 어떻게 호출될지를 머리속으로 그려봐야 하기 때문
    - **즉, 전체 함수 호출 트리를 그릴 수 있어야 함!**
- 각 단계에서 몇 번의 재귀 호출이 연쇄적으로 일어나는지를 알면 시간 복잡도를 계산할 수 있고, 호출 스택의 최대 깊이를 통해서 공간 복잡도 구할 수 있음
- 예를 들어, 함수 내에서 재귀 호출이 한 번만 일어나는 알고리즘의 시간 복잡도와 공간 복잡도는 모두 O(n)이 됨
    - 총 n번 함수 호출이 일어나고, 호출이 깊어도 n이기 때문

```python
f(0)
    f(1)
        f(2)
            f(3)
                f(4)
```

- 함수 내에서 재귀 호출이 한 번 더 일어나면 호출 스택이 한 단계 깊어질 때 마다 호출 수가 2배씩 늘어나기 때문에 시간 복잡도 O(2^n)이 되며, 호출 스택의 깊이는 변하지 않기 때문에 공간 복잡도는 O(n)이 됨

```python
f(0)
    f(1)
        f(2)
            f(3)
                f(4)
                f(4)
            f(3)
                f(4)
                f(4)
        f(2)
            f(3)
                f(4)
                f(4)
            f(3)
                f(4)
                f(4)
    f(1)
        f(2)
            f(3)
                f(4)
                f(4)
            f(3)
                f(4)
                f(4)
        f(2)
            f(3)
                f(4)
                f(4)
            f(3)
                f(4)
                f(4)
```

- 만약에 재귀 호출이 한 번 더 일어나게 되면 각 단계에서 호출 수가 3배씩 늘어나기 때문에 시간 복잡도는 O(3^n)이 되고, 공간 복잡도는 여전히 O(n)
- 만약에 함수 내에서 반복문이 있거나 추가적인 자료구조를 사용한다면 시간 복잡도와 공간 복잡도는 그에 따라 비약적으로 더 늘어날 것
    - **결국 재귀 함수는 로직이 복잡해질 수록 성능이 좋지 않음**
    - **또한, 재귀 함수 특성 상 동일 함수를 또 호출하기 때문에 효율적이지 않음**
    - **이러한 동일 함수 호출 문제를 해결하기위한 성능 최적화 기법은 메모이제이션(Memoization)!**