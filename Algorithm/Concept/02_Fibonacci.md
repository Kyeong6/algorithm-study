## 개념 정리

### 피보나치 알고리즘이란?

- 첫번째 항은 0, 두번재 항은 1, 그 다음부터는 바로 전 두 항의 숫자의 합이 현재 항의 값이 되는 형태

```python
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...]
```

### 구현: 재귀 알고리즘

- 가장 흔한 방식

```python
def fibo(n):
	if n == 0:
		return 0
	if n == 1:
		return 1
	return fib(n-1) + f(n-2)
	
if __name__ == "__main__":
	for n in range(20):
		print(fib(n), end=", ")
```

- 앞서서 배운 재귀 알고리즘을 이용하면 시간 / 공간 복잡도는 모두 O(2^n)으로 매우 비효율적
    - 즉, 인자(n)가 커지면 커질수록 비효율적
- 재귀가 비효율적인 이유는 직접 트리를 그려보면 알겠지만, 동일한 함수가 계속 생성되기 때문
    - **이때 메모이제이션이 필요!**

### 구현: 반복 알고리즘

- 스택(stack)을 이용하면 반복 알고리즘으로 전환할 수 있음
    - 스택은 리스트로 구현 가능

```python
def fibo(n):
	total = 0
	stack = [n]
	while stack:
		n = stack.pop()
		if n < 2:
			total += 2
		else:
			stack.append(n-1)
			stack.append(n-2)
	return total
```

- 위 코드의 시간 / 공간 복잡도는 앞서 작성한 재귀 함수와 동일하지만, 스택오버플로우(stack overflow)를 방지할 수 있는 이점 존재

### 구현: 메모이제이션

- 위의 재귀 트리를 보면 결국 ‘fibo(n)’를 계산하기 위해서는 필요한 것은 fibo(n-1), fibo(n-2) … 결과값
- 따라서, 이 결과 값을 어딘가에 저장해놓고 재활용한다면 중복 계산을 피할 수 있음

```python
def fibo(n):
	memo = {0: 0, 1: 1}
	
	def helper(n):
		if n not in memo: # 사전 정의 확인
			memo[n] = helper(n-1) + helper(n-2)
		return memo[n]
		
	return helper(n)
```

- memo 변수에 딕셔너리를 할당하고, 각 숫자의 계산 결과를 저장함
- 주어진 숫자의 계산 결과가 사전에 저장되어 있지 않은 경우에만 재귀 호출하기 때문에 훨씬 효율적
- 해당 알고리즘의 시간 / 공간 복잡도는 O(n)
    - 함수 호출 횟수와 저장 데이터의 크기가 주어진 숫자에 비례하기 때문

### 구현: 동적 계획법

- 메모이제이션을 사용한 알고리즘의 성능도 나쁘지는 않지만 추가적인 공간 최적화 진행에 동적 계획법 사용
- 피보나치 수열을 어떻게 계산되는 지를 유심히 생각해보면 굳이 모든 수에 대한 계산 결과를 저잦ㅇ해둘 필요가 없다는 사실을 알게 됨
    - **왜냐하면 실제로 매 단계 필요한 것은 전 단계와 바로 전전 단계의 계산 결과이기 때문**
    - **결국 두 개의 변수만 있다면 계속해서 매 단계 저장된 값을 바꿔가면서 재사용할 수 있음**
- 이렇게 더 적은 입력에 대한 답을 먼저 구해서 저장해놓고, 더 큰 입력에 대한 답을 구할 때 활용하는 풀이 기법을 “동적 계획법(Dynamic Programming)”이라고 함

```python
def fibo(n):
	# 다중 할당
	p1, p2 = 0, 1
	for i in range(n):
		p1, p2 = p2, p1 + p2
	return p2
```

- 해당 알고리즘은 고정된 크기의 메모리만 사용하므로 공간 복잡도가 O(1)이 됨